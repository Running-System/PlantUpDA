\section{Experimental Evaluation of MQTT versus REST}

\subsection{Introduction and Research Context}
Chapter 2 established the theoretical foundations: MQTT employs minimal overhead through a binary fixed-header format and publish-subscribe decoupling, while REST incurs substantial per-request overhead due to HTTP's verbose text-based headers and stateless connection model. However, theoretical analysis alone is insufficient when designing battery-constrained IoT systems. Empirical measurements under realistic operating conditions are essential to quantify the actual performance delta and validate architectural decisions.

This chapter presents a controlled comparative experiment evaluating MQTT and REST protocols on identical ESP32-S3 hardware communicating with the Plant Up! backend infrastructure. The objective is to answer: How much ``heavier'' is REST in practice? Does the ``wake-up tax'' of HTTP fundamentally compromise battery viability, or can modern microcontrollers mitigate the overhead through optimized Wi-Fi stacks and faster processors?

\subsection{Experimental Setup Recap}
The experimental design, detailed in full in Chapter 4, employs a within-subjects controlled quasi-experimental approach. Key configuration parameters are reiterated here for context:

\begin{enumerate}
    \item \textbf{Device:} ESP32-S3-WROOM-1 module running ESP-IDF v5.2 firmware with high-precision microsecond timers instrumenting the wake-sleep cycle. Sensors physically attached but not sampled; a static JSON payload eliminates sensor acquisition time as a confounding variable.
    
    \item \textbf{Network:} Residential Wi-Fi network (TP-Link Archer C7 router, 802.11n 2.4GHz, channel 6) with RSSI maintained between --65 dBm and --75 dBm. This represents typical home deployment conditions, including interference from neighboring networks and consumer electronics.
    
    \item \textbf{Backend:} MQTT broker (Eclipse Mosquitto 2.0.18) and Supabase PostgreSQL instance both hosted in AWS eu-central-1 region to minimize asymmetric network latency. MQTT configured for QoS 0 (at-most-once delivery) without TLS encryption. REST configured for HTTPS (TLS 1.2/1.3) per standard web security practices.
    
    \item \textbf{Payload:} Identical static JSON payload (152 bytes) used for both protocols to ensure fair comparison:
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/payload_mqtt_rest.png}
    \caption{Standardized JSON payload used for both MQTT and REST experimental trials}
    \label{fig:payload_structure}
\end{figure}

\subsection{Data Collection Instrumentation}
Data collection employed three complementary measurement techniques to ensure accuracy and cross-validation:

\textbf{On-Device Microsecond Timers:}
The ESP32-S3 firmware logged five critical timestamps per wake-sleep cycle with 1-microsecond resolution: boot start ($T_0$), Wi-Fi connected ($T_1$), payload transmitted ($T_2$), acknowledgment received ($T_3$), and sleep initiated ($T_4$). These timestamps were transmitted via UART to a connected PC for offline aggregation, avoiding filesystem I/O overhead during measurement periods.

\textbf{Network Packet Capture:}
All Wi-Fi traffic to/from the ESP32-S3 was mirrored to a laptop running Wireshark 4.0.3. Post-processing scripts (Python with \texttt{scapy}) parsed PCAP files to extract per-transaction byte counts, accounting for IP headers, TCP headers, application protocol headers (MQTT fixed header vs. HTTP request/response headers), and payload.

\textbf{Database-Level Verification:}
After each transmission, a SQL query verified record insertion into the Supabase \texttt{Controllers} table:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verification_packets.png}
    \caption{SQL verification query validates data persistence and delivery reliability}
    \label{fig:verification_packets}
\end{figure}

This three-pronged approach provides triangulation: device-side timings quantify latency from the edge perspective, packet captures reveal actual network overhead, and database queries confirm successful delivery.

\subsection{Results: Latency and Payload Efficiency}
200 independent transmission cycles were executed for each protocol condition, yielding 400 total trials. Aggregated descriptive statistics are presented in Table \ref{fig:results_table_img}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/markdown-table.png}
    \caption{Comparative performance metrics of MQTT vs. REST under identical test conditions. MQTT demonstrates 70\% latency reduction and 68\% payload size reduction compared to REST.}
    \label{fig:results_table_img}
\end{figure}

\textbf{End-to-End Latency:}
MQTT achieved a mean end-to-end latency of \textbf{185 ms} (SD = 42 ms), while REST exhibited \textbf{612 ms} (SD = 89 ms). This represents a \textbf{70\% reduction} in latency for MQTT (effect size Cohen's $d = 5.76$, $p < 0.001$ via independent samples t-test). The latency difference of ~427 ms translates directly to reduced radio-on time and therefore lower energy consumption per transmission cycle.

\textbf{Effective Payload Size:}
Packet capture analysis revealed that MQTT transmissions consumed an average of \textbf{312 bytes} per cycle (including IP/TCP headers, MQTT fixed header, topic string, and JSON payload), whereas REST transactions totaled \textbf{982 bytes} (including TCP handshake packets, TLS handshake, HTTP request headers, and response). This \textbf{68\% reduction} in bytes-on-wire for MQTT is primarily attributable to:
\begin{itemize}
    \item Amortized connection setup: MQTT establishes a single persistent TCP connection reused across multiple publishes, whereas REST initiates a new connection (TCP + TLS handshake) for each POST request.
    \item Minimal application headers: MQTT fixed header is 2-5 bytes, while HTTP request headers (Host, User-Agent, Authorization, Content-Type, etc.) exceed 200 bytes.
\end{itemize}

\textbf{Reliability:}
Both protocols achieved > 99\% delivery reliability under the test network conditions (MQTT: 199/200 successful, REST: 197/200 successful), suggesting that packet loss is not a dominant concern for either protocol in the evaluated environment. The marginal failures were attributed to transient Wi-Fi disconnections rather than protocol-specific issues.

\subsection{Interpretation: Sources of Latency Differential}
The 70\% latency advantage of MQTT can be decomposed into two primary contributors:

\textbf{(1) Connection Establishment Overhead:}
REST requires three sequential handshake phases for each transmission:
\begin{enumerate}
    \item TCP 3-way handshake: SYN, SYN-ACK, ACK (~1.5 RTT, ~50-75 ms typical)
    \item TLS handshake: ClientHello, ServerHello, Certificate, KeyExchange, Finished (~2 RTT for TLS 1.2, ~100-150 ms)
    \item HTTP request/response exchange (~1 RTT, ~50 ms)
\end{enumerate}
Total connection overhead: ~200-275 ms \textit{before} application logic even begins processing the payload.

In contrast, MQTT establishes the TCP and TLS connection once (during the first publish after wake), and subsequent publishes within the same wake cycle incur zero connection overhead. For a device that wakes, publishes a single message, and immediately sleeps, this difference is critical.

\textbf{(2) Protocol Header Efficiency:}
Beyond connection setup, the per-message protocol overhead differs dramatically:
\begin{itemize}
    \item MQTT fixed header: 2-5 bytes
    \item HTTP request headers (typical): 250+ bytes
    \item HTTP response headers (typical): 150+ bytes
\end{itemize}

For a 152-byte JSON payload, HTTP's header-to-payload ratio is ~2.6:1, whereas MQTT's is ~0.03:1. This bloat extends transmission time proportionally on bandwidth-constrained 2.4GHz Wi-Fi.

\subsection{Anomalies and Outlier Analysis}
Inspection of per-trial latency distributions revealed several notable outliers:

\textbf{REST Latency Spikes:}
Approximately 5\% of REST trials exhibited latency >1000 ms (versus median ~600 ms). Investigation of packet captures identified two primary causes:
\begin{itemize}
    \item \textbf{TCP Retransmissions:} In cases where the initial HTTPS SYN packet was lost (likely due to Wi-Fi interference), the ESP32-S3 TCP stack retransmitted after a 1-second timeout, doubling the connection establishment time.
    \item \textbf{TLS Renegotiation:} Intermittent TLS handshake failures (e.g., cipher suite mismatch or expired session tickets) forced renegotiation, adding ~200 ms to the critical path.
\end{itemize}

\textbf{MQTT Latency Stability:}
MQTT latency distributions exhibited significantly lower variance (SD = 42 ms vs. 89 ms for REST). This stability is attributed to MQTT's asynchronous publish-and-forget semantics (QoS 0): the publisher does not block awaiting application-layer acknowledgment, allowing it to transition to sleep immediately after transmission. In contrast, REST's synchronous request-response model couples sender delays to server processing time and network RTT variance.

\subsection{ Network Conditions and Environmental Variance}
All measurements were acquired with signal strength (RSSI) maintained between --65 dBm and --75 dBm, representative of typical indoor residential environments at 3-5 meters from the access point. To assess sensitivity to network quality, a subset of 50 additional trials was conducted at RSSI --80 dBm (achieved by increasing device-to-router distance to ~8 meters):

\begin{itemize}
    \item \textbf{MQTT latency increase:} +35\% (from 185ms to 250ms)
    \item \textbf{REST latency increase:} +42\% (from 612ms to 870ms)
\end{itemize}

Critically, the \textit{relative} advantage of MQTT persisted across signal strength conditions. The latency gap widened in absolute terms (620ms vs. 427ms at nominal RSSI), suggesting that MQTT's efficiency gains compound under degraded network conditions.

\subsection{Interpretation: Trade-offs and Disclaimer on Generalizability}
The measured 3× latency improvement and 3× bandwidth reduction for MQTT represent best-case scenario under the specific experimental configuration: QoS 0, no MQTT-side TLS, and co-located backend services. Several caveats qualify these results:

\textbf{QoS Level Dependency:}
MQTT QoS 1 (at-least-once delivery) introduces a PUBACK handshake, adding ~50-100ms per publish (1 additional RTT). QoS 2 (exactly-once) requires a four-step handshake, potentially reducing the latency advantage to 1.5-2× compared to REST. For applications demanding guaranteed delivery, the trade-off shifts.

\textbf{TLS Encryption Asymmetry:}
REST used HTTPS (TLS 1.2/1.3), while MQTT operated over unencrypted TCP. Enabling TLS for MQTT would add ~100-150ms for the initial handshake and ~5-10\% encryption overhead per message. However, because MQTT amortizes the TLS handshake across multiple publishes (unlike REST's per-request handshake), the latency gap would narrow but still favor MQTT.

\textbf{Backend Processing Time:}
The measured latency includes backend database insertion time (~20-40 ms typical for Supabase). For workloads where backend processing dominates (e.g., complex analytics pipelines), protocol overhead becomes less significant relative to total end-to-end latency.

\textbf{Payload Size Scaling:}
The evaluated payload (152 bytes) is representative of typical IoT telemetry. For larger payloads (e.g., kilobytes of JPEG image data), HTTP's header overhead becomes proportionally less significant. Conversely, for very small payloads (<50 bytes), HTTP's inefficiency intensifies.

\subsection{Conclusion: Empirical Protocol Selection Guidance}
The controlled experiment provides empirical validation of MQTT's theoretical advantages for battery-constrained sensor-to-cloud communication. For the Plant Up! deployment scenario (periodic telemetry from ESP32-S3 nodes operating on battery power with 10-minute wake intervals), MQTT demonstrably outperforms REST:
\begin{itemize}
    \item \textbf{70\% latency reduction:} Enables faster wake-sleep transitions, reducing average current draw during active cycles.
    \item \textbf{68\% bandwidth reduction:} Lowers data plan costs for cellular-connected deployments (though not applicable in Wi-Fi-only setup).
    \item \textbf{Superior stability:} Lower latency variance under degraded network conditions.
\end{itemize}

However, REST remains the appropriate choice for the mobile application layer, where human users require rich querying capabilities, synchronous request-response semantics, and compatibility with standard web frameworks. The hybrid architecture (MQTT for edge-to-cloud uplink, REST for mobile client access) leverages the strengths of both protocols while mitigating their respective weaknesses.
