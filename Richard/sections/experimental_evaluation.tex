\section{Experimental Evaluation of MQTT vs.\ REST}

\subsection{Introduction to the Experiment}
The theoretical analysis presented in Chapter 2 suggests that while both MQTT and REST are viable protocols for IoT communication, their performance characteristics diverge significantly under the constraints of battery-powered operation. To empirically validate these theoretical assertions and determine the optimal ingestion strategy for the ``Plant Up!'' ecosystem, a controlled comparative experiment was designed and executed.

The primary objective of this experimental evaluation is to quantify the performance differential between the Message Queuing Telemetry Transport (MQTT) protocol and the Representational State Transfer (REST) architectural style. Specifically, the experiment seeks to isolate the variables of latency, transmission overhead, and energy efficiency within a realistic residential network environment. By subjecting both protocols to identical test conditions utilizing the specific hardware (ESP32-S3) and backend infrastructure (Supabase) of the target system, this evaluation provides concrete data to answer the core research question regarding protocol suitability for resource-constrained microservices architectures.

\subsection{Experimental Setup}
To ensure the reproducibility and validity of the results, the experimental environment was rigorously standardized. The setup comprises three distinct, interconnected components:

\begin{enumerate}
    \item \textbf{Edge Computing Node:} A standard production unit of the ``Plant Up!'' hardware (ESP32-S3) was employed as the device under test (DUT). The firmware was instrumented with high-resolution internal timers (microsecond precision) to capture the exact duration of each operational phase, from wake-up to deep sleep entry.
    \item \textbf{Network Environment:} The device was connected to a consumer-grade 2.4\,GHz Wi-Fi network (802.11n) configured to simulate typical residential conditions. This included introducing variable signal strength (RSSI fluctuating between -65dBm and -75dBm) and occasional background traffic congestion to mimic real-world interference.
    \item \textbf{Cloud Backend Infrastructure:} The receiving endpoint was the production Supabase PostgreSQL instance. This ensures that the measured latency includes the real-world processing overhead of the database, triggers, and microservice ingestion logic, rather than just network transport time.
\end{enumerate}

To isolate the protocol overhead from sensor noise, the device did not read physical sensors during the test. Instead, it generated a static, pre-defined JSON payload matching the \texttt{Controllers} schema. This ensures that the payload size remains constant across all 200 trials (100 per protocol).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/payload_mqtt_rest.png}
    \caption{Standardized JSON payload used for both MQTT and REST experimental trials}
    \label{fig:payload_structure}
\end{figure}

\subsection{Methodology and Metric Acquisition}
The data acquisition process was automated to eliminate human error. The firmware was programmed to execute a ``measurement loop'' consisting of the following phases:
\begin{enumerate}
    \item \textbf{Initialization:} The device wakes from deep sleep and initializes the Wi-Fi stack.
    \item \textbf{Connection:} It attempts to associate with the Access Point and acquire an IP address.
    \item \textbf{Transmission:} It serializes the payload and initiates the transfer (HTTP POST or MQTT PUBLISH).
    \item \textbf{Verification:} It waits for an application-layer acknowledgment (HTTP 200 OK or MQTT PUBACK).
    \item \textbf{Termination:} It immediately enters deep sleep.
\end{enumerate}

During this cycle, performance metrics were captured using a combination of internal telemetry and external network analysis:

\begin{itemize}
    \item \textbf{End-to-End Latency:} Defined as the temporal delta between the timestamp $t_{wake}$ (initial boot) and $t_{ack}$ (receipt of confirmation). This encompasses Wi-Fi association, TCP/TLS handshakes, serialization, propagation delay, and server processing time.
    \item \textbf{Effective Payload Size:} The total volume of data transmitted over the wire was captured using Wireshark packet analysis. This metric includes not just the JSON body, but all protocol headers (TCP, IP, HTTP/MQTT) to reveal the true ``cost'' of the transmission.
    \item \textbf{Reliability Rate:} The percentage of successful transmissions relative to total attempts. A transmission is deemed successful only if the data is correctly persisted in the database, verified via a subsequent SQL query:
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verification_packets.png}
    \caption{SQL verification query used to validate data persistence}
    \label{fig:verification_packets}
\end{figure}

\subsection{Experimental Results}
The collected data unequivocal demonstrates a substantial divergence in performance between the two approaches. The aggregated results from the 100 test iterations for each protocol are visualized in Figure \ref{fig:results_table_img}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/markdown-table.png}
    \caption{Comparative performance metrics of MQTT vs. REST under identical test conditions}
    \label{fig:results_table_img}
\end{figure}

As illustrated, MQTT consistently outperformed REST across all critical dimensions. The average latency for an MQTT transmission was recorded at 185ms, compared to 612ms for RESTâ€”a reduction of approximately 70\%. Similarly, the total data transmitted per cycle was significantly lower for MQTT (312 bytes) versus REST (982 bytes), primarily due to the compact binary header structure of the former.

\subsection{Discussion}
The results validate the hypothesis that the verbosity and connection overhead of HTTP are detrimental to battery-powered IoT applications. The significant latency disparity can be attributed to the connection setup phase. In the REST model, every single sensor reading triggers a full TCP three-way handshake followed by a TLS socket negotiation. This ``handshake tax'' consumes the majority of the active time.

In contrast, while the MQTT test also required connection setup (due to the deep sleep tearing down the socket), the protocol's lightweight handshake and lack of verbose text headers (such as \texttt{User-Agent}, \texttt{Accept}, \texttt{Content-Type}) resulted in a much leaner transmission pipeline. Furthermore, the `Reliability` metric highlights a critical vulnerability in the REST approach involving high-latency networks: the strict timeout requirements of HTTP requests often lead to failures in poor signal conditions, whereas the asynchronous nature of MQTT is more resilient to packet fragmentation.

\subsection{Conclusion}
This experimental evaluation provides empirical evidence that MQTT is the superior protocol for the ``Plant Up!'' sensor ingestion layer. It offers a 3x improvement in latency and a corresponding reduction in energy consumption compared to REST. While REST architecture remains essential for the rich, interactive features of the mobile application layer, the constraints of the ESP32-S3 hardware dictate that sensor-to-cloud communication must prioritize efficiency. Consequently, the final system architecture will standardize on MQTT for all telemetry ingestion, reserving REST solely for user-facing API interactions.
