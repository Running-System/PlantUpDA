\section{Experimental Evaluation of MQTT vs.\ REST}

\subsection{Introduction to the Experiment}
Chapter 2 gave us the theory: MQTT is lightweight and fast, while REST is robust but heavy. But theory isn't enough when you're building real hardware. We need to know exactly how much ``heavier'' REST is. Does it drain the battery twice as fast? Ten times as fast? Or is the difference negligible?

To answer this, we didn't just run a simulation. We designed a controlled battle between the two protocols using the actual ``Plant Up!'' hardware and backend. The goal was simple: quantify the performance gap in a real-world setting. We wanted to verify if the ``wake-up tax'' of HTTP really destroys battery life, or if modern microcontrollers handle it better than expected.

\subsection{Experimental Setup}
To make sure our results weren't a fluke, we rigorously standardized the environment. The setup had three main parts:

\begin{enumerate}
    \item \textbf{The Device (Edge Node):} We used a standard ESP32-S3 unit, identical to what a user would have in their plant pot. We modified the firmware to separate the ``Protocol Time'' from the rest of the boot process, using high-precision microseconds timers.
    \item \textbf{The Network:} We didn't use a perfect lab network. We connected the device to a standard home 2.4\,GHz Wi-Fi router with average signal strength (RSSI between -65dBm and -75dBm). We wanted to see how these protocols behave in the messy reality of a residential house.
    \item \textbf{The Backend:} The destination for all data was our live Supabase Production database. This ensures that our latency numbers include everything: the network travel time, the database insertion, and the trigger execution.
\end{enumerate}

To keep things fair, we removed the variable of ``reading sensors''. Instead, the device sent a static, pre-defined JSON definition every single time. This guarantees that the payload size was constant for all 200 tests.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/payload_mqtt_rest.png}
    \caption{Standardized JSON payload used for both MQTT and REST experimental trials}
    \label{fig:payload_structure}
\end{figure}

\subsection{Methodology and Metric Acquisition}
Data collection was fully automated to prevent human error. The firmware ran a rigid "measurement loop":
\begin{enumerate}
    \item \textbf{Wake Up:} The device boots from deep sleep.
    \item \textbf{Connect:} It negotiates with the Wi-Fi router.
    \item \textbf{Send:} It serializes the JSON and pushes it out using either HTTP POST or MQTT PUBLISH.
    \item \textbf{Verify:} It waits until the server replies ``I got it'' (HTTP 200 or MQTT PUBACK).
    \item \textbf{Sleep:} It checks the clock, logs the time, and immediately powers down.
\end{enumerate}

We measured three things:
\begin{itemize}
    \item \textbf{End-to-End Latency:} The stopwatch time from ``Boot'' to ``Server Confirmation''. This counts everything: handshakes, serialization, and propagation.
    \item \textbf{Effective Payload Size:} We used Wireshark to capture the actual packets. This reveals the hidden cost of protocols. You might send 50 bytes of JSON, but how many bytes of headers wrapped it?
    \item \textbf{Reliability:} If we try to send 100 packets, how many actually land in the database?
\end{itemize}

We verified the arrival of every packet using a SQL query on the backend:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verification_packets.png}
    \caption{SQL verification query used to validate data persistence}
    \label{fig:verification_packets}
\end{figure}

\subsection{Experimental Results}
The data speaks for itself. There is a massive performance gap between the two approaches. Figure \ref{fig:results_table_img} shows the aggregated results from our 100 test runs.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/markdown-table.png}
    \caption{Comparative performance metrics of MQTT vs. REST under identical test conditions}
    \label{fig:results_table_img}
\end{figure}

As you can see, MQTT is the clear winner. The average latency was just \textbf{185ms}, compared to a sluggish \textbf{612ms} for REST. That is a reduction of nearly 70\%. Even more telling is the data usage: MQTT used about \textbf{312 bytes} per cycle, while REST bloated to \textbf{982 bytes}.

\subsection{Discussion}
These results confirm our fears about HTTP. It's just too chatty for battery operation. The massive difference in latency comes down to the connection setup. With REST, every single time the plant wants to say ``I'm OK'', the device has to perform a full TCP three-way handshake and a heavy TLS secure socket negotiation. It spends more time shaking hands than actually talking.

MQTT, even though it also has to connect, cuts out all the fluff. It doesn't send massive text headers like \texttt{User-Agent} or \texttt{Content-Type}. It just opens the door, throws the binary packet in, and closes the door. The simpler handshake and binary structure make it far more efficient.

Usefully, we also noticed that REST was more fragile. In our ``messy network'' tests, strictly timed HTTP requests would sometimes timeout and fail completely, whereas MQTT's asynchronous nature allowed it to retry or slip the packet through a smaller window of connectivity.

\subsection{Conclusion}
This experiment gives us empirical proof: MQTT is the superior choice for the ``Plant Up!'' sensor layer. It is 3x faster and significantly lighter on data usage. While we will keep using REST for the mobile app (because it's great for loading user profiles), the ESP32-S3 hardware simply cannot afford the overhead of HTTP for its sensor reporting. We are standardizing on MQTT for all telemetry ingestion. It's the only way to make the battery last long enough for a user to actually enjoy the product.
