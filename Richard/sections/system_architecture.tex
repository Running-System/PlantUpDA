\section{Plant Up! System Architecture and Implementation}

\subsection{System Overview and Requirements}
The ``Plant Up!'' system integrates IoT hardware, microservices and a mobile application into a unified platform designed to support real-time plant monitoring and social interaction. The primary system objective is to collect environmental sensor data from consumer-grade hardware, synchronize it across distributed cloud services and present it to users in a gamified, socially engaging interface.

To achieve this, the system must satisfy three key requirements:
\begin{itemize}
    \item \textbf{Low-latency sensor synchronization:} Environmental data must be transmitted and processed fast enough to provide timely feedback on plant health.
    \item \textbf{Energy-efficient operation:} IoT devices must conserve battery life through deep sleep cycles, lightweight payloads and minimal active radio time.
    \item \textbf{Distributed consistency:} Since data is stored across multiple domain-specific schemas, the system must tolerate intermittent connectivity while ensuring eventual consistency.
\end{itemize}

These requirements shape the architectural decisions in both hardware and microservices. The system therefore follows a multi-layered design consisting of an edge node, a cloud microservices layer and a client application layer.

\subsection{Hardware Layer: The Edge Node}
The hardware layer consists of an ESP32-S3 microcontroller equipped with sensors for temperature, humidity, light intensity, soil moisture and electrical conductivity. This configuration enables comprehensive monitoring of plant health. The device operates under strict energy constraints and therefore relies heavily on deep sleep modes. Upon waking, it performs three tasks:

\begin{enumerate}
    \item Reads environmental sensors.
    \item Serializes the data into a compact JSON structure.
    \item Sends the payload to the backend via MQTT or REST before returning to deep sleep.
\end{enumerate}

The JSON payload corresponds to the structure of the \texttt{Controllers} table in the \texttt{microcontroller\_schema}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Sensor payload structure.png}
    \caption{JSON payload sent by the edge node}
    \label{fig:edge_json_payload}
\end{figure}

The corresponding Supabase table is:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Controllers table in microcontroller__schema.png}
    \caption{Controllers table receiving IoT data}
    \label{fig:controllers_table_rx}
\end{figure}

By timestamping each measurement, the backend can reconstruct time series data even when devices experience connectivity delays, enabling eventual consistency.

\subsection{Microservice Architecture Design}
The backend adopts a microservices-inspired architecture grounded in Supabase schemas. Each schema represents a bounded context aligned with a specific domain:

\begin{itemize}
    \item \textbf{user\_schema}: Stores user profiles, streak data and virtual currency.
    \item \textbf{social\_media\_schema}: Manages posts, comments, plants and plant metadata.
    \item \textbf{microcontroller\_schema}: Stores IoT sensor measurements and device associations.
    \item \textbf{gamification}: Contains quests, user quest progress and XP statistics.
\end{itemize}

This separation allows backend services to evolve independently and prevents cross-domain interference. For example, the creation of a post does not impact sensor ingestion, and a device update does not affect quest completion logic.

An example of domain separation is evident in the \texttt{Plants} table:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Plants table.png}
    \caption{Plants table in social\_media\_schema}
    \label{fig:plants_table_arch}
\end{figure}

This table links user-owned plants to ideal environmental parameters in \texttt{Plant\_data}, enabling health comparisons by other services.

\subsection{Real-Time Data Synchronization Mechanism}
Real-time synchronization in ``Plant Up!'' requires balancing two competing goals: minimizing battery usage on the edge node while providing timely updates to the microservices layer. Two communication mechanisms are evaluated:

\begin{itemize}
    \item \textbf{REST (HTTPS)} offers structured, authenticated, synchronous transmission suitable for user-driven interactions but incurs significant overhead.
    \item \textbf{MQTT} provides lightweight, publish/subscribe semantics with lower transmission cost, making it more suitable for the ESP32-S3.
\end{itemize}

Sensor data is synchronized using a hybrid approach. IoT controllers publish sensor payloads through MQTT for efficiency. The backend processes the incoming data and stores it in \texttt{microcontroller\_schema.Controllers}. User-facing services such as the mobile app retrieve the aggregated data via REST.

A typical ingestion operation is represented by:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Insert example for sensor readings.png}
    \caption{Insert operation for real-time sensor synchronization}
    \label{fig:insert_op_sync}
\end{figure}

Since devices may reconnect sporadically, synchronization follows an eventually consistent model rather than strict ordering guarantees.

\subsection{Social Gamification Logic Implementation}
Gamification is integrated into the Plant Up! experience to motivate sustained engagement. The gamification subsystem relies on three core tables:

\begin{itemize}
    \item \textbf{Quests}: Defines daily and weekly goals.
    \item \textbf{User\_quests}: Tracks per-user quest progression.
    \item \textbf{player\_stats}: Stores XP and level totals.
\end{itemize}

For example, the quests table is defined as:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Quests table in gamification schema.png}
    \caption{Quests table in gamification schema}
    \label{fig:quests_table}
\end{figure}

When a user completes an action, such as watering a plant or posting an update, the backend increments their quest progress:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/User quest progression.png}
    \caption{User quest progression}
    \label{fig:user_quest_progression}
\end{figure}

Once the target count is met, XP is awarded:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Awarding XP to player_stats.png}
    \caption{Awarding XP to player\_stats}
    \label{fig:xp_award}
\end{figure}

This modular design ensures that the gamification logic remains independent of the sensor ingestion pipeline, social media features and plant data system.
