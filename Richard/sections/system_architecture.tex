\section{Plant Up! System Architecture and Implementation}

\subsection{System Overview and Vision}
The ``Plant Up!'' platform is where the physical world of botany meets the digital world of social networking. It integrates distributed IoT hardware, a scalable cloud microservices backend, and a vibrant mobile application into a single, unified ecosystem. This is the practical realization of the Social Internet of Things (SIoT) concept: giving plants a digital ``voice'' to tell us how they feel. The primary goal is straightforward but technically demanding: collect high-precision environmental data from our custom edge devices, synchronize it through the cloud, and present it to users in a way that feels like a game, not a chore.

To bring this vision to life, our architecture must solve three critical puzzles:
\begin{itemize}
    \item \textbf{Low-latency sensor synchronization:} When a plant is thirsty, the user needs to know \textit{now}. We must close the loop between the biological need and the human action as fast as possible.
    \item \textbf{Energy-efficient operation:} No one wants to charge their plant pot every day. Our IoT devices need to be ``install-and-forget'', sipping battery power through intelligent deep sleep cycles and minimal radio usage.
    \item \textbf{Distributed consistency:} With data scattered across User, Social, and Hardware domains, the system has to keep everything in sync, even when the Wi-Fi acts up.
\end{itemize}

These requirements drive every choice we made, from the specific sensors we soldered to the board to the way we structured our microservices. The result is a multi-layered design: the Edge Node, the Cloud Layer, and the Application Layer.

\subsection{Hardware Layer: The Edge Node}
The hardware layer is the physical ``nervous system'' of our project. It builds a bridge between the digital cloud and the soil in the pot. We built it around the ESP32-S3 microcontroller and equipped it with a comprehensive suite of sensors for temperature, humidity, light, soil moisture, and electrical conductivity. This gives us a complete picture of the plant's health. But because it runs on a battery, it spends most of its life asleep. Its routine is simple but strict:
\begin{enumerate}
    \item \textbf{Acquisition:} Wake up, power on the sensors, and take a quick snapshot of the environment.
    \item \textbf{Serialization:} Pack those numbers into a compact JSON format.
    \item \textbf{Transmission:} Fire that packet off to the cloud (using MQTT or REST) and go back to sleep immediately.
\end{enumerate}

\subsubsection{Component Selection and Sensor Interface}
Hardware selection isn't just about features; it's about the trade-off between capability and longevity.

\textbf{Microcontroller: Espressif ESP32-S3}
The brain of our operation is the ESP32-S3. We chose it for its perfect balance of power and efficiency. It has a dual-core processor and built-in Wi-Fi and Bluetooth, but the real star is its Ultra-Low Power (ULP) co-processor. This little chip allows the main power-hungry CPU to sleep while basic monitoring continues in the background. At around 20 Euro, it gives us incredible bang for our buck.

\textbf{Soil Moisture Sensor: HiLetgo LM393}
Water is life, and the HiLetgo LM393 (approx. 7.89 Euro) allows us to measure it. Unlike cheaper sensors that corrode in weeks, this resistive sensor measures the dielectric permittivity of the soil. It gives us that critical ``I'm thirsty'' signal.

\textbf{Light Sensor: HiLetgo BH1750}
Plants eat light, so we need to measure it accurately. We use the BH1750 (approx. 11.39 Euro). It's a digital I2C sensor, not a cheap photo-resistor. It gives us precise lux readings, so the system can tell you, ``Hey, I need more sun,'' or ``I'm getting sunburned!''

\textbf{Electrical Conductivity (EC) Sensor: DFRobot Gravity V2}
This is where we go beyond the basics. The DFRobot Gravity Analog EC Sensor (approx. 12.10 Euro) measures Electrical Conductivity, which is essentially the salt content of the soil.
\begin{itemize}
    \item \textit{Why EC?} EC correlates directly with nutrients. A droopy plant might be watered perfectly but starving for nitrogen. This sensor allows ``Plant Up!'' to predict when you need to fertilize, turning it from a simple watering alarm into a true health monitor.
\end{itemize}

\textbf{Power Supply and Sustainability}
To keep this running remotely, we pair a lithium-ion battery with a 0.5W Photo-voltaic Solar Panel (approx. 3.48 Euro). It's designed to be self-sustaining, but we included a USB-C port just in case.

\subsubsection{Data Structure}
All this sensor data gets wrapped up into a tidy JSON payload. This maps directly to the \texttt{Controllers} table in our backend `microcontroller\_schema`:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Sensor payload structure.png}
    \caption{JSON payload sent by the edge node}
    \label{fig:edge_json_payload}
\end{figure}

And here is where it lands in Supabase:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/controllers_table.png}
    \caption{Controllers table receiving IoT data}
    \label{fig:controllers_table_rx}
\end{figure}

Crucially, we timestamp every measurement right at the source (the edge node). This means that even if the Wi-Fi is down for an hour, when the data finally arrives, the backend knows exactly when it was recorded. This allows us to reconstruct accurate historical charts despite network hiccups.

\subsection{Microservice Architecture Design}
Our backend isn't a tangled mess of code; it's a family of microservices organized around Supabase schemas. Each schema acts as a ``Bounded Context'', which is a fancy way of saying it minds its own business:
\begin{itemize}
    \item \textbf{user\_schema}: Handles the players: profiles, streaks, and virtual wallets.
    \item \textbf{social\_media\_schema}: Handles the community: posts, comments, and plant profiles.
    \item \textbf{microcontroller\_schema}: The data warehouse for all those sensor readings.
    \item \textbf{gamification}: The game engine: quests, progress, and XP.
\end{itemize}

This separation is a lifesaver for development. We can tweak the way quests work without worrying about breaking the sensor ingestion pipeline. A problem in one area doesn't cascade into a total system failure.

For instance, the \texttt{Plants} table in the social schema links a user's plant to its ideal growing conditions in \texttt{Plant\_data}. This allows other services to look up ``What does a Monstera need?'' without cluttering the social database with botanical encyclopedias.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Plants table.png}
    \caption{Plants table in social\_media\_schema}
    \label{fig:plants_table_arch}
\end{figure}

\subsection{Real-Time Data Synchronization Mechanism}
Synchronization is a balancing act. We want the user to see fresh data instantly, but we don't want to kill the sensor's battery. We evaluated two main contenders:
\begin{itemize}
    \item \textbf{REST (HTTPS)}: The standard web way. It's structured and familiar, great for when a user loads their profile. But for sending tiny sensor packets every few minutes? The overhead is heavy.
    \item \textbf{MQTT}: The IoT specialist. It's lightweight and uses a publish/subscribe model. Theoretically, this is the perfect match for our battery-constrained ESP32.
\end{itemize}

We ended up using a hybrid approach. The IoT devices talk MQTT because it's efficient. A backend service listens to that chatter and commits it to the database. The user's phone app then talks to the database using standard REST APIs. It's the best of both worlds.

A typical data ingestion looks like this:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Insert example for sensor readings.png}
    \caption{Insert operation for real-time sensor synchronization}
    \label{fig:insert_op_sync}
\end{figure}

\subsection{User Engagement and Data Processing}
The ``Social'' and ``Gamification'' parts of Plant Up! aren't just cosmetic; they are the engine that drives user behavior. This logic lives in the \texttt{gamification} schema, and it watches the data streaming in from the other layers.

It relies on three core tables:
\begin{itemize}
    \item \textbf{Quests}: The menu of challenges, like "Water your Monstera" or "Check the light level".
    \item \textbf{User\_quests}: The user's personal to-do list.
    \item \textbf{player\_stats}: The scorecard: XP and levels.
\end{itemize}

The \texttt{quests} table sets the stage:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/quests_table.png}
    \caption{Quests table in gamification schema}
    \label{fig:quests_table}
\end{figure}

Here is the magic: When the sensor layer detects that the soil moisture just shot up, the system implies, ``Aha! The user watered the plant.'' The processing service triggers an update to the user's quest progress. Physical action -> Digital Notification.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/user_quest.png}
    \caption{User quest progression}
    \label{fig:user_quest_progression}
\end{figure}

And when the goal is met (say, watering 3 times in a week), the system showers the user with XP.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/awarding_xp.png}
    \caption{Awarding XP to player\_stats}
    \label{fig:xp_award}
\end{figure}

This modular design keeps the fun stuff separate from the serious plumbing. We can tune the game mechanics, such as making quests harder or adding holiday events, without ever having to touch the firmware on the edge devices.
