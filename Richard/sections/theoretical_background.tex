\section{Theoretical Background}

\subsection{Microservices Architecture (MSA)}
Microservices Architecture (MSA) describes a software design approach in which an application is decomposed into small, autonomous services that communicate through lightweight protocols \cite{ref20}. Each service is responsible for a specific domain and can be deployed and scaled independently. For IoT systems, where hardware events, sensor data ingestion, user interactions and analytics occur asynchronously, this architectural style offers clear advantages in resilience and scalability \cite{ref21}.

The ``Plant Up!'' project follows this principle by organizing its backend into domain-oriented Supabase schemas: the \texttt{user\_schema} manages identities and streak logic, the \texttt{social\_media\_schema} stores posts and plant information, the \texttt{gamification} schema handles XP, quests and rewards, and the \texttt{microcontroller\_schema} stores IoT sensor readings. Each schema acts as an isolated bounded context.

A representative example is the table for environmental sensor readings:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Controllers table in microcontroller__schema.png}
    \caption{Controllers table in microcontroller\_schema}
    \label{fig:controllers_table}
\end{figure}

This separation prevents side effects: updating sensor data cannot interfere with social media functionality or gamification services. MSA therefore supports robustness and domain clarity.

\subsection{Core Characteristics of Microservices in IoT}
IoT systems introduce unique requirements that make certain microservice characteristics particularly important. Constrained hardware, intermittent connectivity and asynchronous event streams require an architecture that is tolerant to partial failures and scalable under variable load.

\textbf{Autonomy:}  
Each service must function independently. For example, the gamification subsystem maintains XP and level state regardless of the status of the sensor ingestion pipeline:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Gamification player statistics.png}
    \caption{Gamification player statistics}
    \label{fig:gamification_stats}
\end{figure}

\textbf{Loose Coupling:}  
Services communicate through clearly defined data structures. A social media post does not depend on the microcontroller service:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Posts table in social__media__schema.png}
    \caption{Posts table in social\_media\_schema}
    \label{fig:posts_table}
\end{figure}

\textbf{Scalability:}  
Sensor bursts occur when multiple devices wake simultaneously. Only the ingestion path needs to scale, not the entire backend.

\textbf{Resilience:}  
Since IoT devices frequently disconnect (deep sleep, Wi-Fi loss), the system must tolerate missing or delayed data. The schema boundaries allow delayed writes without blocking dependent features.

\subsection{JSON Payload Design}
JSON is used throughout Plant Up! for communication between mobile clients, backend services and IoT devices. Because the ESP32-S3 is battery-powered, payload size and structure directly influence energy consumption \cite{ref22}.

A typical payload aligned with the \texttt{Controllers} schema is:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Sensor payload structure.png}
    \caption{Sensor payload structure}
    \label{fig:sensor_payload}
\end{figure}

The payload reflects several design principles:
\begin{itemize}
    \item flat JSON structure to avoid deep nesting,
    \item short but descriptive field names to reduce size,
    \item consistent alignment with database schema,
    \item predictable field order for efficient parsing on constrained hardware.
\end{itemize}

Such optimizations reduce transmission time and extend device battery life.

\subsection{Internet of Things (IoT) Constraints and Hardware}
IoT hardware such as the ESP32-S3 operates under constraints that strongly influence backend architecture.

\textbf{1. Power Consumption:}  
Deep sleep drastically reduces energy usage, but each wake cycle incurs overhead due to Wi-Fi reconnection and sensor initialization. This ``wake-up tax'' conflicts with real-time monitoring needs \cite{ref23}.

\textbf{2. Intermittent Connectivity:}  
Home networks produce variable latency. Timestamped readings (\texttt{time}) allow the backend to reconstruct temporal context even with delayed uploads.

\textbf{3. Limited Compute and Memory:}  
Operations like TLS negotiation, JSON serialization and sensor polling must be minimized.

\textbf{4. Sensor Noise \& Calibration:}  
Environmental data such as soil moisture, EC and humidity fluctuate naturally. The backend must treat sensor readings as approximations and potentially smooth or validate them before using them for plant health scoring or gamification.

These constraints justify efficient protocols and eventual consistency strategies.

\subsection{Communication Protocols: MQTT vs. REST}
Communication choices fundamentally shape IoT system performance. In Plant Up!, both REST and MQTT serve different roles.

\textbf{REST (HTTPS):}  
REST is used for structured, authenticated application features such as user data, posts, quests and plant profiles. For example, plant instances are stored as:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Plants table.png}
    \caption{Plants table}
    \label{fig:plants_table}
\end{figure}

REST integrates seamlessly with Supabase but introduces overhead due to large HTTP headers and TLS handshakes, which is suboptimal for energy-constrained IoT devices.

\textbf{MQTT:}  
MQTT is a lightweight publish/subscribe protocol optimized for constrained hardware \cite{ref24}. Devices publish compact JSON messages to predefined topics and immediately return to deep sleep. This minimizes active Wi-Fi time and improves battery longevity.

A topic pattern suitable for Plant Up! is:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/topic pattern for Plant Up! .png}
    \caption{Topic pattern for Plant Up!}
    \label{fig:topic_pattern}
\end{figure}

\textbf{Architectural Implication:}  
Plant Up! adopts a hybrid model:
\begin{itemize}
    \item REST for app features requiring authentication and structured queries,
    \item MQTT for energy-efficient, low-latency sensor data ingestion.
\end{itemize}

\subsection{Data Consistency and the CAP Theorem}
In distributed systems, the CAP theorem states that a system cannot simultaneously provide Consistency (C), Availability (A) and Partition Tolerance (P) \cite{ref25}. Since IoT systems must assume network partitions due to intermittent connectivity, Partition Tolerance is unavoidable.

Plant Up! prioritizes Availability and Partition Tolerance (AP), accepting that sensor readings may arrive late and the system will become consistent over time.

Upon reconnection from deep sleep, readings are inserted into the \texttt{Controllers} table:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Insert example for sensor readings.png}
    \caption{Insert example for sensor readings}
    \label{fig:insert_example}
\end{figure}

Analytics and gamification services operate on this eventually consistent data. This ensures:
\begin{itemize}
    \item the mobile app remains responsive,
    \item no sensor data is lost during connectivity gaps,
    \item gamification logic (e.g., XP, quests) updates when sufficient data is available.
\end{itemize}

This trade-off aligns with the practical constraints of consumer IoT devices.
