IoT Data Sync in Microservices: Evaluating MQTT vs. REST
1. Introduction
1.1 Background and Context
The integration of the Internet of things (IoT) into our lives has been rapid, especially in the agricultural sector which has started a transformation known as â€œAgriculture 4.0â€, where data-driven decision making replaces traditional heuristic methods [1]. While industrial has benefited form that shift, a parallel trend is emerging in the consumer sector. Smart Urban gardening [2]. Driven by rapid urbanization and growing societal focus on sustainability, this sector is experiencing significant growth [3]. This surge represents a shift toward the Social Internet of Things (SIoT) [4]. In the SIoT paradigm, objects are capable of establishing social relationships with other objects and humans to foster collaboration[5] However, applying these advanced concepts to consumer grade hardware presents architectural challenges [6]. Unlike industrial systems, consumer IoT devices for plant care must operate in resource constrained environments, reyling on batteries and communicating over congested residential Wi-Fi [7].
1.2 Case Study: The "Plant Up!" Project
This thesis utilizes the â€œPlant Up!â€ project as a primary case study to investigate architecural frictions [8]. â€œPlant Up!â€ is an IoT application designed to gamify the experience of plant care [9]. The system combines hardware sensor units (IoT devices), cloud services and a mobile app to monitor soil moisture, temperature, humidity, light levels and other metrics in real time. The codebase relies on a three tier architecture: edge layer (esp32), the microservices layer and the Application layer [11].
1.3 Problem Statement
The design of a real time social plant monitoring system with gamification aspects introduces a conflict between latency, energy efficiency and data consistency [12]. The â€œSocialâ€ aspect relies on gamification mechanics that require low latency data transmission [13]. However, the hardware must utilize aggressive power saving states and techniques to be practical for home use [14]. Research indicates that while deep sleep extends battery life, the wake up and following processes cause latency that conflicts with real time requirements [15]. Furthermore, the choice of communication protocol dictates the â€œwake up taxâ€ of the device [16]. Traditional web protocols like HTTP are robust but carry significant header overhead, whereas lightweight protocols like MQTT are designed for exactly that missing efficiency [17]. Additionally, maintaining a consistent view of the system state in a distributed architecture is non trivial, as the CAP theorem dictates trade offs between Consistency, Partition tolerance and Availability [18]
1.4 Research Question
To address these challenges, this thesis poses the following primary research question:
How do MQTT and REST compare in a microservices-based architecture for real-time plant monitoring, specifically regarding latency, throughput, and data consistency, when constrained by battery-powered IoT devices [19]? 
2. Theoretical Background
2.1 Microservices Architecture (MSA)
Microservices Architecture (MSA) represents a shift in software design, moving away from monolithic architectures toward the decomposition of applications into multiple small services [20]. For "Plant Up!", a monolithic approach would be detrimental due to inefficient scaling [21]. MSA defines the application as a suite of small services, each running in its own process, enabling distinct services such as Dashboard, Notification, Processing, and Ingestion services to function separately [22].
2.2 Core Characteristics of Microservices in IoT
Services are independently deployable components, allowing for the evolution of the cloud platform without requiring firmware updates on edge devices [23]. Unlike monoliths, MSA encourages "Database per Service," ensuring services are loosely coupled in state [24]. For instance, the Notification Service might use a Time-Series Database like InfluxDB, while the User Service uses a Relational Database [25]. This necessitates reliance on eventual consistency models [26]. Furthermore, the system must handle dynamic loads through containerization and orchestration, allowing services to auto-scale based on traffic [27].
2.3 JSON Payload Design
Communication typically occurs via synchronous REST APIs or asynchronous messaging using JSON serialization [28]. Standardizing the data contract is vital [29].
In contrast, a RESTful response from the 
Dashboard Service
 to a user's browser might utilize HATEOAS (Hypermedia as the Engine of Application State) to guide the client through the application state, a core tenet of RESTful theory.
2.2.4 Challenges of MSA in IoT
While MSA offers scalability, it introduces significant complexity, particularly for IoT applications like "Plant Up!".
Network Latency
: In a monolith, communication is in-memory function calls. In MSA, communication is over the network. Each "hop" between services adds latency. If a user requests a plant status, the Dashboard Service might call the Plant Service, which calls the Database, adding milliseconds of network overhead at each step [30].
Distributed Tracing
: Debugging a failure requires tracing a request across multiple service boundaries. If the "Plant Up!" dashboard shows outdated data, the error could be in the sensor, the MQTT broker, the Ingestion Service, or the Database. Tools and patterns for correlated logging (using 
trace_id
 as seen in the JSON example) are mandatory [31].
2.3 Internet of Things (IoT) Constraints and Hardware
2.3.1 The ESP32 Microcontroller Architecture
The "Plant Up!" project relies on the ESP32, a low-cost, low-power system on a chip (SoC) developed by Espressif Systems. It features a dual-core XtensaÂ® 32-bit LX6 microprocessor, integrated Wi-Fi (802.11 b/g/n), and dual-mode Bluetooth [33] Theoretical analysis of the ESP32's power architecture is critical because the choice of software protocol (MQTT vs. REST) directly dictates the hardware's active duration, which is the main factor in battery life.
The ESP32 operates in several power modes, each with distinct consumption profiles [33]:
Active Mode
: The CPU, radio (Wi-Fi/BT), and peripherals are fully powered. In this state, the device consumes between 
160mA and 260mA
 when transmitting (Tx) and 
80mA-90mA
 when receiving (Rx) [34]. This is the most expensive state.
Light Sleep
: The CPU is paused, and the clock is gated, but RAM is retained. Wake-up is rapid (<1ms). Consumption is approx 
0.8mA
 [33].
Modem Sleep
: The CPU is active, but the Wi-Fi/Bluetooth radio baseband is disabled. Consumption drops to 
20mA-30mA
 [35]. This mode is used when processing data locally without transmitting.
Deep Sleep
: This is the critical mode for "Plant Up!". The CPU, Wi-Fi, Bluetooth, and most RAM are powered down. Only the ULP (Ultra-Low Power) coprocessor and the RTC (Real-Time Clock) controller remain active. Consumption drops to 
10ÂµAâ€“150ÂµA
 [33]. 
Hibernation
: Everything is off except the RTC timer. Consumption is 
~5ÂµA 
[33].
2.3.2 Energy Management Theory: The Duty Cycle
Connection Overhead
: The ESP32 does not maintain a Wi-Fi connection in Deep Sleep. Upon waking, it must re-associate with the Access Point (AP) and acquire an IP address via DHCP. This process typically takes 
1 to 3 seconds
, consuming 
~100-150mA
 on average [36]. This "connection tax" is paid regardless of the application layer protocol.
Protocol Handshake
:
REST/HTTPS
: Requires a TCP handshake (SYN, SYN-ACK, ACK) followed by a TLS handshake (ClientHello, ServerHello, Certificate Exchange, Key Exchange). This involves multiple round-trips (RTT) before data is sent.
MQTT (Secure)
: Also requires TCP and TLS handshakes to establish the secure tunnel. However, if the device stays awake (Modem Sleep) and maintains the connection, subsequent messages have zero handshake overhead. If the device Deep Sleeps (breaking the connection), MQTT 
also
 requires a 
CONNECT
 packet handshake upon waking [37].
2.3.3 Deep Sleep and Memory Constraints
In Deep Sleep, the main SRAM is volatile. The ESP32 provides a small 
8KB RTC Slow Memory
 that retains data during deep sleep [38]. This allows for "Store and Forward" architectures where the "Plant Up!" device wakes up, reads a sensor, stores the value in RTC memory, and goes back to sleep 
without
 turning on the Wi-Fi. After 
n
 cycles, it wakes up fully, connects, and bulk-uploads data. This strategy amortizes the high energy cost of the Wi-Fi connection over multiple readings.
The "Plant Up!" firmware must carefully manage this memory. While REST is stateless, MQTT libraries often require state (packet IDs, session flags). Implementing robust MQTT on the ESP32 requires handling the loss of this state if the device enters Deep Sleep, often necessitating the use of the 
cleanSession=false
 flag or explicit state saving in RTC memory [39].
2.4 Communication Protocols: MQTT vs. REST
The selection of the communication protocol is the pivotal technical decision for the "Plant Up!" data synchronization layer, influencing energy efficiency, data latency, and reliability.
2.4.1 MQTT (Message Queuing Telemetry Transport)
MQTT is a lightweight, binary, publish-subscribe messaging protocol running on top of TCP/IP, standardized by ISO/IEC 20922. It was explicitly designed for bandwidth-constrained and unreliable networks, making it a strong candidate for agricultural IoT.
20
2.4.1.1 Publish-Subscribe Architecture
Unlike the point-to-point nature of REST, MQTT utilizes a 
Broker
 to decouple clients.
Decoupling
: The "Plant Up!" sensor (Publisher) sends data to a topic (e.g., 
plantup/nursery/sensor01/moisture
). It does not know who consumes this data. The Broker routes this message to the 
Ingestion Service
 (Subscriber).
20
Space and Time Decoupling
: The Publisher and Subscriber do not need to be online simultaneously (if persistent sessions are used). This supports the "Plant Up!" requirement for intermittent connectivity.
2.4.1.2 Packet Structure and Overhead
MQTT is binary-encoded. The fixed header is only 
2 bytes
.
16
Byte 1: Packet Type (4 bits) + Flags (4 bits).
Byte 2: Remaining Length.
This minimal overhead contrasts sharply with HTTP, where text-based headers (User-Agent, Content-Type, Authorization) can easily exceed 500 bytes per request, even for a 10-byte payload. For a cellular-connected "Plant Up!" sensor, this overhead reduction translates directly to data cost savings and reduced radio-on time.22
2.4.1.3 Quality of Service (QoS) Levels
MQTT provides three distinct levels of message delivery guarantees, allowing "Plant Up!" to balance reliability against energy cost 
20
:
QoS 0 (At most once)
: "Fire and forget." The message is transmitted, and no acknowledgment is expected. This is the most energy-efficient but risks data loss. It is suitable for periodic soil moisture readings where a missing data point is not critical.
QoS 1 (At least once)
: Ensures delivery. The sender stores the message and waits for a 
PUBACK
. If not received, it retransmits. This is ideal for critical alerts (e.g., "Pump Failure"), though it requires idempotency handling in the microservice to manage duplicates.
QoS 2 (Exactly once)
: Uses a four-step handshake (
PUBLISH
, 
PUBREC
, 
PUBREL
, 
PUBCOMP
). This incurs significant latency and network overhead and is generally too heavy for battery-powered ESP32 sensors.
2.4.1.4 MQTT Implementation on ESP32
The following code snippet illustrates the use of the 
PubSubClient
 library for "Plant Up!". It demonstrates the connection logic and publishing mechanism. The 
loop()
 function is critical for maintaining the connection and processing incoming 
SUBACK
 or 
PUBACK
 messages.
Analysis
: The 
client.loop()
 function is blocking in nature regarding network processing. If the connection is lost, 
reconnect()
 blocks execution. For Deep Sleep applications, the connection is torn down every cycle, meaning the 
reconnect()
 logic runs on every wake-up, incurring the full handshake cost.
24
2.4.2 REST (Representational State Transfer)
REST is an architectural style that utilizes the existing features of the web (HTTP) for communication. It is the standard for web APIs and integrates seamlessly with web-based microservices.
2.4.2.1 Request-Response Model
REST is synchronous. The ESP32 sends a request (e.g., 
POST /readings
) and waits for a response.
Statelessness
: The server retains no session information. Each request must contain authentication tokens (e.g., JWT) and all context. This simplifies the server-side architecture for "Plant Up!" but increases the data payload size per message.
Simplicity
: REST over HTTP is text-based and easy to debug. It maps CRUD operations (Create, Read, Update, Delete) to HTTP verbs (POST, GET, PUT, DELETE).
26
2.4.2.2 Performance and Energy Implications
Header Bloat
: As noted, HTTP headers are verbose.
TCP Efficiency
: HTTP/1.1 allows for 
Keep-Alive
 connections to reuse the TCP socket for multiple requests. However, if the ESP32 sleeps for 10 minutes between readings, the TCP socket will timeout (typically 60s-120s server-side), rendering 
Keep-Alive
 useless. Thus, every reading requires a new TCP and TLS handshake.
Latency
: The request-response nature implies a Round Trip Time (RTT) dependency. High latency on a cellular network directly extends the radio-on time.
16
2.4.2.3 REST Implementation on ESP32
The comparative REST implementation uses the 
HTTPClient
 library. This approach is conceptually simpler but requires explicit management of the JSON string construction.
Analysis
: The 
http.begin
 and 
http.end
 sequence indicates a fresh connection setup and teardown. While simpler to implement than the MQTT state machine, the overhead of establishing the secure channel (
WiFiClientSecure
) on every loop is significant in terms of energy.
27
2.4.3 Comparative Summary
The theoretical comparison suggests a divergence in suitability based on use case.
2.5 Data Consistency and the CAP Theorem
Integrating distributed IoT data into a microservices architecture introduces complex challenges regarding the consistency of the system's state. When a "Plant Up!" sensor reports a critical moisture drop, how quickly does that data propagate to the alert service, and can we guarantee every service sees the same data simultaneously?
2.5.1 The CAP Theorem Definition
The CAP Theorem, formulated by Eric Brewer, posits that in any distributed data store, it is impossible to simultaneously provide more than two of the following three guarantees 
8
:
Consistency (C)
: Every read receives the most recent write or an error. In "Plant Up!", this implies that if Sensor A reports 10% moisture, the Dashboard Service, Notification Service, and Automation Service all see 10% immediately.
Availability (A)
: Every request receives a (non-error) response, without the guarantee that it contains the most recent write. This means the system stays up and responsive even if some data is not yet synchronized.
Partition Tolerance (P)
: The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network.
2.5.2 Applying CAP to "Plant Up!"
In the context of IoT and Wireless Sensor Networks (WSN), 
Partition Tolerance (P)
 is a non-negotiable reality. Wireless signals in a greenhouse can be blocked by foliage, metal structures, or interference, creating network partitions where sensors cannot reach the cloud broker.
30
Therefore, the architectural choice is reduced to 
CP
 vs. 
AP
:
CP (Consistency + Partition Tolerance)
: If the network is partitioned, the system refuses to accept new data or serve requests to prevent inconsistency. For "Plant Up!", this would mean if the cloud database cannot replicate data to a secondary node, the Ingestion Service would reject incoming sensor readings. This is unacceptable, as data loss (missing a drought event) is a greater risk than reading slightly stale data.
AP (Availability + Partition Tolerance)
: The system prioritizes accepting data and serving requests. If a partition occurs, the Ingestion Service accepts the sensor reading and stores it locally or in a queue, synchronizing with the rest of the system later. The Dashboard might show old data for a few seconds, but the system remains functional.
8
2.5.3 Eventual Consistency in IoT
Given the necessity of an 
AP
 design, "Plant Up!" adopts the model of 
Eventual Consistency
. This model guarantees that if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value.
32
The "Plant Up!" architecture manages this via the MQTT Broker and the Microservices event bus:
Write Path
: Sensor publishes to MQTT -> Ingestion Service picks up message -> Writes to Supabase (Primary Write).
Read Path
: Dashboard reads from a Redis Cache.
Synchronization
: An asynchronous process updates the Redis Cache from Supabase.
There is a window of inconsistency ($t_{inconsistency}$) between step 1 and step 3. During this window, a user might see the old moisture level. However, for environmental monitoring, a latency of seconds is acceptable, validating the AP approach.
Conflict Resolution
: Challenges arise in bi-directional control. If a user sends a "Turn Pump ON" command via REST (Dashboard), and an automated rule sends a "Turn Pump OFF" command via MQTT (Processing Service) simultaneously, a conflict occurs. Theoretical resolution strategies include "Last Write Wins" (LWW) based on high-precision timestamps, or Vector Clocks to determine causality.
32
 For "Plant Up!", LWW is typically sufficient given the relatively slow physical dynamics of soil moisture.
